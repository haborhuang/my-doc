# Redis高效率的原因
参考https://blog.csdn.net/lch_2016/article/details/81078243 

* 绝大部分请求是纯粹的内存操作，非常快速。
* 采用单线程，避免了不必要的上下文切换和竞争条件。
* IO多路复用。单线程处理高并发网络请求的原因。

## Redis是单线程？

* 单线程指的是网络请求模块使用了单线程进行处理。其他模块不然。
  
## 线程上下文切换的开销

一些概念：
* 上下文切换指CPU从一个进行（或线程）切换到另一个进程（或线程）。
* 上下文是指一个时间点CPU寄存器和程序计数器的内容。
* 上下文切换：
  * 挂起当前进程的执行，将寄存器内容存到内存中。
  * 在内存中获取下一个待执行的进程的上下文，恢复到寄存器中。
  * 跳转到程序计数器指向的位置，恢复进程执行。

切换开销：
上下文切换是计算密集型的。频繁的切换需要消耗大量的CPU时间。

## IO多路复用

参考：https://www.cnblogs.com/john8169/p/9780484.html

* 背景：I/O相关的系统调用会阻塞进程运行，无法执行其他操作。
* Redis实现了单独模块处理多路复用，该模块封装了底层实现（如select或epoll，因为不同系统提供的底层实现不同）并对外提供API。
* 多路复用模块对外输出事件，事件处理过程可概括为：获取句柄，read请求，处理及响应。

### select、poll和epoll

select：
* select 内部实现使用了FD_SETSIZE宏（32位系统为1024），受其限制select监听的fd数量最多为FD_SETSIZE个。
* select调用时会遍历指定的socket集合来找出就绪的fd，时间复杂度为O(n)
* 每次调用会复制fd集合到内核。

poll：相比select基本一致，不同的是使用链表存储fd集合，从而突破fd数量限制

epoll：
* 通过epoll_ctl注册fd，只会拷贝一次fd。
* 每个fd对应一个回调函数，数据就绪后执行回调，回调会将fd加入一个就绪链表。
* epoll_wait返回就绪链表的fd。时间复杂度O(1)。

### IO模型

* blocking IO。如recvfrom操作阻塞进程，当数据准备好，从kernal拷贝到用户内存后，才解除阻塞。
* non-blocking IO。通过标记位设置为非阻塞，recvfrom会立即返回，并通过返回值表示不同的状态。程序需要循环调用。
* IO multiplexing（多路复用）。如select和epoll。可以理解底层将socket轮询逻辑封装起来，并管理多个socket fd。如某一个fd数据就绪后select就返回，再通过recvfrom读取数据。
* signal-driven IO，信号驱动。通过系统调用设置处理函数，调用立即返回不阻塞。数据准备好后，信号通知进程，然后执行处理函数，需在处理函数中执行recvfrom接收数据。
* asynchronous IO，异步IO。系统调用后立即返回，数据准备好并完成用户内存拷贝后，通知进程或回调进程处理函数。进程并不需要recvfrom接收数据。

前四种都属于同步，与异步的区别在于：同步IO需要调用recvfrom，将数据从内核空间拷贝到用户空间，此过程会导致阻塞。而异步IO会在拷贝完成后再通知进程。
